# 编写高质量代码：改善Java程序的151个建议

## 第1章　java开发中通用的方法和准则/1

* 1： 不要在常量和变量中出现易混淆的字母/2
* 2： 莫让常量蜕变成变量/2
* 3： 三元操作符的类型务必一致/3
* 4： 避免带有变长参数的方法重载/4
* 5： 别让null值和空值威胁到变长方法/6
* 6： 覆写变长方法也循规蹈矩/7
* 7： 警惕自增的陷阱/8
* 8： 不要让旧语法困扰你/10
* 9： 少用静态导入/11
* 10： 不要在本类中覆盖静态导入的变量和方法/13
* 11： 养成良好习惯，显式声明uid/14
* 12： 避免用序列化类在构造函数中为不变量赋值/17
* 13： 避免为final变量复杂赋值/19
* 14： 使用序列化类的私有方法巧妙解决部分属性持久化问题/20
* 15： break万万不可忘/23
* 16： 易变业务使用脚本语言编写/25
* 17： 慎用动态编译/27
* 18： 避免instanceof非预期结果/29
* 19： 断言绝对不是鸡肋/31
* 20： 不要只替换一个类/33

## 第2章　基本类型/35

* 21： 用偶判断，不用奇判断/36
* 22： 用整数类型处理货币/37
* 23： 不要让类型默默转换/38
* 24： 边界，边界，还是边界/39
* 25： 不要让四舍五入亏了一方/41
* 26： 提防包装类型的null值/43
* 27： 谨慎包装类型的大小比较/45
* 28： 优先使用整型池/46
* 29： 优先选择基本类型/48
* 30： 不要随便设置随机种子/49

## 第3章　类、对象及方法/52

* 31： 在接口中不要存在实现代码/53
* 32： 静态变量一定要先声明后赋值/54
* 33： 不要覆写静态方法/55
* 34： 构造函数尽量简化/57
* 35： 避免在构造函数中初始化其他类/58
* 36： 使用构造代码块精炼程序/60
* 37： 构造代码块会想你所想/61
* 38： 使用静态内部类提高封装性/63
* 39： 使用匿名类的构造函数/65
* 40： 匿名类的构造函数很特殊/66
* 41： 让多重继承成为现实/68
* 42： 让工具类不可实例化/70
* 43： 避免对象的浅拷贝/71
* 44： 推荐使用序列化实现对象的拷贝/73
* 45： 覆写equals方法时不要识别不出自己/74
* 46： equals应该考虑null值情景/76
* 47： 在equals中使用getclass进行类型判断/77
* 48： 覆写equals方法必须覆写hashcode方法/78
* 49： 推荐覆写tostring方法/80
* 50： 使用package-info类为包服务/81
* 51： 不要主动进行垃圾回收/82

## 第4章　字符串/83

* 52： 推荐使用string直接量赋值/84
* 53： 注意方法中传递的参数要求/85
* 54： 正确使用string、stringbuffer、stringbuilder/86
* 55： 注意字符串的位置/87
* 56： 自由选择字符串拼接方法/88
* 57： 推荐在复杂字符串操作中使用正则表达式/90
* 58： 强烈建议使用utf编码/92
* 59： 对字符串排序持一种宽容的心态/94

## 第5章　数组和集合/97

* 60： 性能考虑，数组是首选/98
* 61： 若有必要，使用变长数组/99
* 62： 警惕数组的浅拷贝/100
* 63： 在明确的场景下，为集合指定初始容量/101
* 64： 多种最值算法，适时选择/104
* 65： 避开基本类型数组转换列表陷阱/105
* 66： aslist方法产生的list对象不可更改/107
* 67： 不同的列表选择不同的遍历方法/108
* 68： 频繁插入和删除时使用linkedlist/112
* 69： 列表相等只需关心元素数据/115
* 70：子列表只是原列表的一个视图/117
* 71： 推荐使用sublist处理局部列表/119
* 72： 生成子列表后不要再操作原列表/120
* 73： 使用comparator进行排序/122
* 74： 不推荐使用binarysearch对列表进行检索/125
* 75： 集合中的元素必须做到compareto和equals同步/127
* 76： 集合运算时使用更优雅的方式/129
* 77： 使用shuffle打乱列表/131
* 78： 减少hashmap中元素的数量/132
* 79： 集合中的哈希码不要重复/135
* 80： 多线程使用vector或hashtable/139
* 81： 非稳定排序推荐使用list/141
* 82： 由点及面，一叶知秋—集合大家族/143

## 第6章　枚举和注解/145

* 83： 推荐使用枚举定义常量/146
* 84： 使用构造函数协助描述枚举项/149
* 85： 小心switch带来的空值异常/150
* 86： 在switch的default代码块中增加assertionerror错误/152
* 87： 使用valueof前必须进行校验/152
* 88： 用枚举实现工厂方法模式更简洁/155
* 89： 枚举项的数量限制在64个以内/157
* 90： 小心注解继承/160
* 91： 枚举和注解结合使用威力更大/162
* 92： 注意@override不同版本的区别/164

## 第7章　泛型和反射/166

* 93： java的泛型是类型擦除的/167
* 94： 不能初始化泛型参数和数组/169
* 95： 强制声明泛型的实际类型/170
* 96： 不同的场景使用不同的泛型通配符/172
* 97： 警惕泛型是不能协变和逆变的/174
* 98： 采用的顺序是list[t]、list[?]、list[object]/176
* 99： 严格限定泛型类型采用多重界限/177
* 100： 数组的真实类型必须是泛型类型的子类型/179
* 101： 注意class类的特殊性/181
* 102： 适时选择getdeclared×××和get×××/181
* 103： 反射访问属性或方法时将accessible设置为true /182
* 104： 使用forname动态加载类文件/184
* 105： 动态加载不适合数组/186
* 106： 动态代理可以使代理模式更加灵活/188
* 107： 使用反射增加装饰模式的普适性/190
* 108： 反射让模板方法模式更强大/192
* 109： 不需要太多关注反射效率/194

## 第8章　异常/197

* 110： 提倡异常封装/198
* 111： 采用异常链传递异常/200
* 112： 受检异常尽可能转化为非受检异常/202
* 113： 不要在finally块中处理返回值/204
* 114： 不要在构造函数中抛出异常/207
* 115： 使用throwable获得栈信息/210
* 116： 异常只为异常服务/212
* 117： 多使用异常，把性能问题放一边/213

## 第9章　多线程和并发/215

* 118： 不推荐覆写start方法/216
* 119： 启动线程前stop方法是不可靠的/218
* 120： 不使用stop方法停止线程/220
* 121： 线程优先级只使用三个等级/224
* 122： 使用线程异常处理器提升系统可靠性/226
* 123： volatile不能保证数据同步/228
* 124： 异步运算考虑使用callable接口/232
* 125： 优先选择线程池/233
* 126： 适时选择不同的线程池来实现/237
* 127： lock与synchronized是不一样的/240
* 128： 预防线程死锁/245
* 129： 适当设置阻塞队列长度/250
* 130： 使用countdownlatch协调子线程/252
* 131： cyclicbarrier让多线程齐步走/254

## 第10章　性能和效率/256

* 132： 提升java性能的基本方法/257
* 133： 若非必要，不要克隆对象/259
* 134： 推荐使用“望闻问切”的方式诊断性能/261
* 135： 必须定义性能衡量标准/263
* 136： 枪打出头鸟—解决首要系统性能问题/264
* 137： 调整jvm参数以提升性能/266
* 138： 性能是个大“咕咚”/268

## 第11章　开源世界/271

* 139： 大胆采用开源工具/272
* 140： 推荐使用guava扩展工具包/273
* 141： apache扩展包/276
* 142： 推荐使用joda日期时间扩展包/280
* 143： 可以选择多种collections扩展/282

## 第12章　思想为源/285

* 144： 提倡良好的代码风格/286
* 145： 不要完全依靠单元测试来发现问题/287
* 146： 让注释正确、清晰、简洁/290
* 147： 让接口的职责保持单一/294
* 148： 增强类的可替换性/295
* 149： 依赖抽象而不是实现/298
* 150： 抛弃7条不良的编码习惯/299
* 151： 以技术员自律而不是工人/301
